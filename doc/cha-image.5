.\" Automatically generated by Pandoc 3.3
.\"
.TH "cha\-image" "5" "" "" "Image support in Chawan"
.SH Inline images
On terminals that support images, Chawan can display various bit\-mapped
image formats.
.PP
Warning: both this document and the implementation is very much WIP.
Anything described in this document may change in the near future.
.SS Enabling images
There are actually two switches for images in the config:
.IP \[bu] 2
buffer.images: this enables downloading images, \f[I]even if they cannot
be displayed\f[R].
.IP \[bu] 2
display.image\-mode: sets the inline image display method.
Defaults to \[lq]auto\[rq], but may also be set to \[lq]sixel\[rq] or
\[lq]kitty\[rq] manually.
.PP
In most cases, all you need to do is to set \[lq]buffer.images\[rq] to
true; with the default image\-mode, Chawan will find the best image
display method supported by your terminal.
.PP
However, there are terminals (such as yaft) that support an image output
method but do not advertise it (and are therefore left undetected).
For such terminals, you also have to set \[lq]display.image\-mode\[rq]
appropriately.
.SS Output formats
Supported output formats are:
.IP \[bu] 2
The DEC SIXEL format
.IP \[bu] 2
The Kitty terminal graphics protocol
.PP
The former is supported because it\[cq]s ubiquitiously adopted; the
latter because it is technically superior to all existing alternatives.
.PP
Support for other protocols (iTerm, MLTerm, etc.)
is not planned.
(To my knowledge, all image\-capable terminals support at least one of
the above two anyways.)
.PP
Support for hacks such as w3mimgdisplay, ueberzug, etc.
is not planned.
.SS Input formats
Currently, the supported input formats are:
.IP \[bu] 2
BMP, PNG, JPEG, GIF (through stb_image)
.IP \[bu] 2
WebP (through JebP)
.PP
More formats may be added in the future, provided there exists a
reasonably small implementation, preferably in the public domain.
(I do not want to depend on external image decoding libraries, but
something like stbi is OK to vendor.)
.SS Codec module system
All image codec implementations are specified by the URL scheme
\[lq]img\-codec+name:\[rq], where \[lq]name\[rq] is the MIME subtype.
e.g.\ for image/png, it is \[lq]img\-codec+png:\[rq].
Like all schemes, these are defined (and overridable) in the
urimethodmap file, and are implemented as local CGI programs.
These programs take an encoded image on stdin, and dump the decoded RGBA
data to stdout \- when encoding, vice versa.
.PP
This means that it is possible (although rarely practical) for users to
define image decoders for their preferred formats, or even override the
built\-in ones.
(If you actually end up doing this for some reason, please shoot me a
mail so I can add it to the bonus directory.)
.PP
A codec can have one of, or both, \[lq]decode\[rq] and \[lq]encode\[rq]
instructions; these are set in the path name.
So \[lq]img\-codec+png:decode\[rq] is called for decoding PNGs, and
\[lq]img\-codec+png:encode\[rq] for encoding them.
.PP
Headers are used for transferring metadata (like image dimensions), both
from the browser (input) and to the browser (output).
Detailed description of the decoder & encoder interfaces follows.
.SS decoding
When the path equals \[lq]decode\[rq], a codec CGI script must take a
binary stream of an encoded image on its standard input and print the
equivalent binary stream of big\-endian 8\-bit (per component) RGBA
values to stdout.
.PP
If specified, it also has to resize said image first.
.PP
Input headers:
.IP \[bu] 2
Cha\-Image\-Info\-Only: 1
.PP
This tells the image decoder to only send image metadata (i.e.\ size).
Technically, the decoder is free to actually decode the image too, but
the browser will ignore any output after headers.
.IP \[bu] 2
Cha\-Image\-Target\-Dimensions: {width}x{height}
.PP
Mutually exclusive with Cha\-Image\-Info\-Only; this instructs the
decoder to also resize the output image.
The dimension format is such that for e.g.\ 123x456, 123 is width and
456 is height.
.PP
(Readers of good taste might consider this header to be a questionable
design decision, but remember that both the decoder and encoder
effectively require copying the output image (thru stdio).
Combined with the current file loader implementation, this means that
in\-browser image resizing would require at least two unnecessary
copies.
.PP
A future design might solve this problem better through shared memory.)
.PP
Output headers:
.IP \[bu] 2
Cha\-Image\-Dimensions: {width}x{height}
.PP
The final size of the decoded image.
If the image was resized through Cha\-Image\-Target\-Dimensions, then
this header\[cq]s value will match the value specified there.
.PP
Again, the dimension format is such that e.g.\ for 123x456, 123 is width
and 456 is height.
.SS encoding
When the path equals \[lq]encode\[rq], a codec CGI script must take a
binary stream of big\-endian 8\-bit (per component) RGBA values on its
standard input and print the equivalent encoded image to its standard
output.
.PP
Input headers:
.IP \[bu] 2
Cha\-Image\-Dimensions: {width}x{height}
.PP
Specifies the dimensions of the input RGBA image.
This means that {width} * {height} * 4 == {size of data received on
stdin}.
.PP
The format is the same as above; in fact, the design is such that you
could directly pipe the output of decode to encode (and vice versa).
.IP \[bu] 2
Cha\-Image\-Quality: {number}
.PP
The requested encoding quality, ranging from 1 to 100 inclusive
(i.e.\ 1..100).
It is up to the encoder to interpret this number.
.PP
(The stb_image JPEG encoder uses this.)
.PP
Output headers:
.PP
Currently, no output headers are defined for encoders.
